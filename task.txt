Моя задача:
- веб-интерфейс для просмотра состояния системы,
- TCP or HTTP порт для входных данных, запроса состояния,
- база данных для хранения данных (транзакции, пул потоков к базе, preparedStatement, …),
- логирование.

Есть два сервера на разных портах portX & portY.
portX – варианты:
1) HTTP сервер, который крутиться на базе embedded Jetty. 
- занимается обслуживаем web-интерфейса. Принимает запросы по HTTP, переадресует запросы на TCP сокет, на порт portY.

2) WebSocket сервер на базе Jetty или Netty.
3) WebSocket сервер, самописный.
- работает с JS частью на фронтенде, которая делает постоянные запросы посредством WebSocket на сервер.
Алгоритм:
- пользователь делает запрос на сервер Apache, где лежит страничка HTML + JS. 
- страничка скачивается пользователю, после этого код JS начинает делает запросы на порт portX по протоколу WebSocket

device <--TCP--> ServerSocket(IO/NIO) <-> DatabaseService <-> ConnectionPool <-Transaction-> Database 

бизнес-логика крутиться в отдельных потоках, правила загружаються из файла или как-то по-другому.
бизнес-логика делает параллельно со всеми запросы в базу данных

Алгорим работы:
- все датчики после включения подключаються к серверу и висят онлайн,

- сервер на базе NIO, т.е. способен держать много соединений онлайн,

- датчики перидически посылают свое состояние, которое пишеться в базу с меткой времени, 
в случае резкого изменения параметра -> датчик посылает состояние вне очереди,

- бизнес-логика раз в N-й промежуток времени делает запрос состояния всей системы у базы, 
результат сохраняеться в коллекцию List<Device> deviceCollection, 

- далее бизнес-логика обрабатывает это все //и вызывает лисенеры, которые предопределены заранее,

- если нужно отдать команду на выполнение, то сервер посылает пакет датчику, 
т.е. ложит пакет в общую очередь через сервис, который потом раскидывает все по соответствующим потокам,

- на сервере крутиться много потоков, 

- эти потоки синхронизированно берут входные данные из общей коллекции объектов, 
однако имеют свою внутреннюю коллекцию с ссылками на внешнюю коллекцию и 
в зависимости от состояния обьектов внутренней коллекции происходит влияние на обьекты внешней коллекции или какие-то события,

- в каждом потоке есть свои коллекции: входных устройств, выходных устройств, ... . 
Однако там содержаться лишь ссылки на основную коллекцию, любое изменение или 
доступ идет через синхронизированные методы сервиса доступа к коллекции устройств.

- если бизнес-логика хочет изменить состояние устройства, то вызывает метод setOutputState() 
соответствующего объекта (как вариант изменяет его значение в базе, а сам объект подтягивается из базы).
Объект в это время находиться в deviceCollection... 


class Device:
//- тип реакции: INPUT, OUTPUT, INPUT_OUTPUT;
- id устройства (адрес);
- тип устройства; 
- текущее состояние;
- время последнего опроса;
- напряжение питания;


class InputDevice extends Device:
- const MOVING, CONTACT, SMOKE, FIRE, WATER, GAS, BREAKGLASS
- тревожный уровень входного сигнала (MAX);//объект класса возможно будет иметь возможность самостоятельно проверять 
вхождение входного уровня в эти пределы и выдавать реакцию
- тревожный уровень входного сигнала (MIN);


class OutputDevice extends Device:
- const RELAY;
- состояние на выход (setOutputState() -> запрос через сокет);
- коллекция listener-ов, которые реагируют на изменение состояния





